<!DOCTYPE html>
<html>
	<body>

		<div id="submit-mid">
			<div id="submit-div" class="k-header">
				<h2>New Job Submit Form</h2>
				<div id="submitInfo-div">
					<p>If you click the "Submit" button, the form-data will be sent to a page called "/action_page.php".</p>
				</div>
				<div id="submitForm-div">
					<form method="POST" id="mainForm" name="mainForm" enctype="application/x-www-form-urlencoded" action="action_page.php">
						<table align="center" width="80%">
							<tr>
								<th align="left">Your Email:</th>
								<th>
									<input type="email" id="user_email" name="user_email" value="Guest" class="k-textbox" readonly required />
									<!--  <input type="email" id="user_email" name="user_email" value="samuelfloresc@gmail.com" class="k-textbox" readonly required /> -->
								</th>
							</tr>
							<tr>
								<th align="left">Job Cohort:</th>
								<th>
									<input type="text" id="jobName" name="jobName" value="homoScan.1" class="k-textbox" readonly />
								</th>
							</tr>
							<tr>
								<th align="left">PDB ID:</th>
								<th>
									<input type="text" id="pdbId" onkeyup="validatePdbAndPopulateChains()" name="pdbId" value="" class="k-textbox" autofocus required />
								</th>
							</tr>
						</table>
						<br> 

						<br>

						Add/remove chains to  1:<br>
						<button id="addChain1Button" type="button" class="k-button" onclick="addChainRow(1)" disabled >Add chain to  1</button>
						<button id="deleteChain1Button" type="button" class="k-button" onclick="deleteChainRow(1)" disabled >Remove chain from  1</button>
						<br> 

						<!-- This table holds the chain IDs   -->
						<table id="chains1Table" name="chains1Table" style="" align="center"></table>
						<br>
						Add/remove chains to  2:<br>
						<button id="addChain2Button" type="button" class="k-button" onclick="addChainRow(2)" disabled >Add chain to  2</button>
						<button id="deleteChain2Button" type="button" class="k-button" onclick="deleteChainRow(2)" disabled >Remove chain from  2</button>
						<br> 

						<!-- This table holds the chain IDs   -->
						<table id="chains2Table" name="chains2Table" style="" align="center"></table>
						<br>
						Add/remove mutations (use PDB residue numbering):<br>
						<button id="addSubstitutionButton" type="button" class="k-button" onclick="addSubstitutionRow()" disabled >Add substitution</button>
						<button id="deleteMutationButton" type="button" class="k-button" onclick="deleteSubstitutionRow()" disabled >Remove substitution</button>
						<br> 

						<table id="substitutionTableHeader" name="substitutionTableHeader" style="" align="center"></table>
						<table id="substitutionTable" name="substitutionTable" style="" align="center"></table>

						<br>
					</form> 

					<p align="center">
						<button class="k-button" id="submit-btn" onclick="formSubmitProcedure()" disabled>Submit</button>
					</p>
				</div>
			</div>
		</div>

	</body>



<script>
	// Fills in the User's Email
	function loadAccInfo() {
		$("#loading-img").fadeIn("slow");
		
		$.ajax({
			type: "POST",
			url: "calls.php",
			dataType: 'json',
			data: {restcall: 'getUserInfo', arguments: [user]},
			success: function(accInfo_data) {
                                console.log("check 32 : " + accInfo_data.email);
                                document.getElementById("user_email").value = accInfo_data.email;
				//$("#user_email").html(accInfo_data.email);
				$("#loading-img").fadeOut("slow");
			},
			error: function(accInfo_jqXHR, accInfo_textStatus, accInfo_errorThrown) {
				popupNotification.show("Error loading User info: " + accInfo_jqXHR.responseText, "error");
				$("#loading-img").fadeOut("slow");
			}
		});
	};

    // Should only be called AFTER document.allPdbChains is properly populated
    function populateRemainingPdbChains(){
        console.log("check 27.0");
        if (!(document.allPdbChains.length > 1)) { 
           alert("Error! Not enough chains found!"); 
        }
        document.remainingPdbChains = document.allPdbChains.slice(); // the slice() method ensures that we copy the array by value rather than by reference. https://stackoverflow.com/questions/7486085/copying-array-by-value-in-javascript
        for (var h = 1; h < 3; h++){
            var myTable =  document.getElementById("chains" + h + "Table");
            console.log("check 27.1"); 
            console.log(document.remainingPdbChains);
            console.log("check 27.2"); 
            for (var i = 0; i < myTable.rows.length; i++) {
                    var myIndex = document.remainingPdbChains.indexOf(myTable.rows[i].cells[0].childNodes[0].value)
                    console.log("table " + h + " row " + i + " has chain " + myTable.rows[i].cells[0].childNodes[0].value);
                    console.log("Looking for " + myTable.rows[i].cells[0].childNodes[0].value);
                    if (myIndex != -1){ // If one of the user-selected chains is found in document.remainingPdbChains ..
                        console.log("Deleting " + myTable.rows[i].cells[0].value);
                        document.remainingPdbChains.splice(myIndex,1); // Remove the corresponding chain from document.remainingPdbChains
                        console.log("Deleting " + myTable.rows[i].cells[0].value);
                    } else { // Actually this should never happen.
                        alert("Somehow you have selected a chain which is not in the protein! Or maybe you selected the same chain more than once!");
                    }
            }
        }     
    }

    function populateChainArrays(){
            var xhttp = new XMLHttpRequest(); // May need variant to handle old IE browsers https://www.w3schools.com/js/js_ajax_http.asp
            console.log("Detected 1 at your PDB ID is valid. You may now add chains.");

            xhttp.onreadystatechange = function() {
                if (this.readyState == 4 && this.status == 200) {
                    console.log(JSON.parse(this.responseText)) ;
                    var myTempChainIdArray = JSON.parse(this.responseText);
                    var myChainIdArray = []; // casting these as arrays
                    document.allPdbChains = []; // casting these as arrays
                    document.remainingPdbChains = [];
                    for (var i = 0; i< myTempChainIdArray.length; i++){
                        myChainIdArray.push(myTempChainIdArray[i].chainId);  
                        document.allPdbChains.push(myTempChainIdArray[i].chainId); // trying to make sure the array gets passed by value not reference
                        //document.remainingPdbChains.push(myTempChainIdArray[i].chainId); // trying to make sure the array gets passed by value not reference
                    }
                    console.log("check 26.5");
                    populateRemainingPdbChains();            
                    console.log(myChainIdArray);
                    document.usedPdbChains = [];
                } else {
                    console.log(this.status) ;
                }
            }; 
            xhttp.open("POST", "calls.php", true ); // Going with asynchronous as I don't want to move on until the chains are ready. Revisit this decision later.
            console.log(this.status) ;
            xhttp.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"); // this turns out to be crucial!
            console.log(document.getElementById("pdbId").value );
            // Argument is user-provided PDB ID:
            xhttp.send("restcall=getPdbChains&arguments[]=" + document.getElementById("pdbId").value ); // calls.php contains a SWITCH on 'restcall'
    }

    function populatePdbPrimaryArray(complex1, complex2){
        if (complex1 === undefined) {
            complex1 = "";
        } 
        if (complex2 === undefined) {
            complex2 = "";
        }
        var myPdbIdArray = [];
        var xhttp = new XMLHttpRequest(); 
        xhttp.onreadystatechange = function() {
        if (this.readyState == 4 && this.status == 200) {
                console.log(JSON.parse(this.responseText)) ;
                var myTempPdbPrimaryArray = JSON.parse(this.responseText);
                document.pdbPrimaryArray = []; // make sure this array is empty
                for (var i = 0; i< myTempPdbPrimaryArray.length; i++){
                    document.pdbPrimaryArray.push(myTempPdbPrimaryArray[i].pdbPrimary); // trying to make sure the array gets passed by value not reference
                    console.log(myTempPdbPrimaryArray[i]);
                }
                console.log(document.pdbPrimaryArray);
                console.log(document.pdbPrimaryArray.join());
                // moved this up from validatePdbAndPopulateChains, so it onlky happens after we are done with document.pdbPrimaryArray .
                document.getElementById("pdbId").readOnly = true ;
                document.getElementById("pdbId").value = document.getElementById("pdbId").value.toUpperCase();     
                document.getElementById("addChain1Button").disabled = false;
                document.getElementById("addChain2Button").disabled = false;

                function checkPdbIdMatches(thisPdbId){
                   return thisPdbId ==  document.getElementById("pdbId").value ; 
                }
                
                console.log("check 25.0");
                //console.log ( countAndFillSequenceTable( document.getElementById("pdbId").value ) );
                //console.log("check 25.0.1");
                if (!(chainTablesInCorrectOrder())){ // This function will pop up an informative alert if the tables are in the wrong order. it takes no further action.     
                    console.log("check 25.1");
                    for (var numComplex = 1; numComplex < 3; numComplex++)
                    {
                        for (var i = 0; i < document.getElementById("chains"+numComplex+"Table").rows.length; i++) {deleteChainRow(numComplex);}
                    }
                    deleteSubstitutionRow();
                    populateChainArrays();
                } else if (document.pdbPrimaryArray.length == 0){
                    // There is no primaryPdb associated with the user-provided PDB ID. This is a completely new protein. Do nothing special.
                    console.log("no pdbPrimary found for this PDB ID. This is a new PDB ID.");
                    alert("Your specified PDB ID " + document.getElementById("pdbId").value + " is not a member of any existing family of homologous PDB IDs. This is evidently the first time this PDB ID is used. ");
                } else if (!(document.pdbPrimaryArray.find( checkPdbIdMatches ) === undefined )) { // If one of the elements of document.pdbPrimaryArray is  document.getElementById("pdbId")
                    if (document.pdbPrimaryArray.length >  1) {
                        alert("Your specified PDB ID  is already the head of more than one existing family of homologous PDB IDs. This is good, let's keep this PDB ID for now. For your information, this pdbID is a member of families headed by : " + document.pdbPrimaryArray.join());
                    } else {
                        alert("Your specified PDB ID "+  document.getElementById("pdbId").value + "  is the head of exactly  one existing family of homologous PDB IDs. That means there are already submissions for at least one mutation of this complex. This is good, let's continue.");
                    }
                    ////alert("Your specified PDB ID " + document.getElementById("pdbId") + " is already the head of at least one existing family of homologous PDB IDs. If at all possible we should try to do the calculations within the context of an existing family. The candidate families are headed by : " + document.pdbPrimaryArray.join());
                } else {
                    if (!((complex1 == "") && (complex2 == ""))){
                        alert("Your specified PDB ID " + document.getElementById("pdbId").value + " and complex " +complex1 + "," + complex2 + " . This combination has already been submitted as a homologous family headed by PDB ID: " +  document.pdbPrimaryArray.join() + " . You are now obligated to switch to PDB ID " + document.pdbPrimaryArray[0] + " . "); 
                        for (var numComplex = 1; numComplex < 3; numComplex++)
                        {
                            for (var i = 0; i < document.getElementById("chains"+numComplex+"Table").rows.length; i++) {deleteChainRow(numComplex);}
                        }
                        deleteSubstitutionRow();
                        document.getElementById("pdbId").value = document.pdbPrimaryArray[0];
                        populateChainArrays();
                        //document.getElementById("pdbId").text = document.pdbPrimaryArray[0];
                    }
                    else if (confirm("Your specified PDB ID " + document.getElementById("pdbId").value + " is a member of homolog families headed by the following PDB ID(s): " +  document.pdbPrimaryArray.join() + " . As you can see, it is not the head of any of these families. We STRONGLY recommend switching to one of these other PDB IDs. Press OK to make the switch to " + document.pdbPrimaryArray[0] + " . ")) {
                        document.getElementById("pdbId").value = document.pdbPrimaryArray[0];
                        populateChainArrays();
                        //document.getElementById("pdbId").text = document.pdbPrimaryArray[0];
                    };

                }




           } else {
                console.log(this.status) ;
            }
           console.log(document.getElementById("pdbId").value);
        }; 
        xhttp.open("POST", "calls.php", true   ); // Going with asynchronous 
        xhttp.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"); // this turns out to be crucial!
        // Argument is user-provided PDB ID:
        //xhttp.send("restcall=getPdbPrimary&arguments[]=" + document.getElementById("pdbId").value ); // calls.php contains a SWITCH on restcall
        if ((complex1 == "") && (complex2 == ""))
            xhttp.send("restcall=getPdbPrimary&arguments[]=" + document.getElementById("pdbId").value ); // calls.php contains a SWITCH on restcall
        else if  ((complex1 == "") || (complex2 == "")) {alert("One of your complexes is empty!"); return;}
        else {
            var myQuery = "restcall=getPdbPrimary&arguments[0]=" + document.getElementById("pdbId").value +"&arguments[1]=" + complex1 + "&arguments[2]=" + complex2;   
            console.log(myQuery);
            xhttp.send(myQuery);
            //xhttp.send("restcall=getPdbPrimary&arguments[]=" + document.getElementById("pdbId").value +"&" + complex1 + "&" + complex2); 
        }

    }

    function validatePdbAndPopulateChains(){
        var myChainIdArray = [];
        if (!(validatePdbIdLength())) {
            return false; // First make sure the length is right
        } else {
            document.getElementById("pdbId").value = (document.getElementById("pdbId").value).toUpperCase() ; // we standardize to uppercase PDB IDs throughout this server.
            document.pdbPrimaryArray = []; // casting these as arrays
            populatePdbPrimaryArray();
                // moved this up to populatePdbPrimaryArray()     , so it onlky happens after we are done with document.pdbPrimaryArray .
            console.log("Detected that your PDB ID is valid. You may now add chains.");
            populateChainArrays();
        }
    }

    function validatePdbIdLength(){
        var pdbIdElement = document.getElementById("pdbId"); 
        var lengthPdbId  = pdbIdElement.value.length;
        //alert(lengthPdbId);
        if (lengthPdbId == 4) {
            return(true); 
        } else return false;
    }
    function sortChainRows( numComplex ){
        var myTable =  document.getElementById("chains"+numComplex+"Table");
        console.log("check 20");
        console.log(numComplex);
        function compareChainRows(j,k){
            console.log("check 21");
            console.log(numComplex);
            var myTable =  document.getElementById("chains"+numComplex+"Table");
            console.log(myTable.rows.length );
            if (myTable.rows[j].cells[0].childNodes[0].value < myTable.rows[k].cells[0].childNodes[0].value ) {
                console.log( " < " );
                return 1;}
            else if (myTable.rows[j].cells[0].childNodes[0].value == myTable.rows[k].cells[0].childNodes[0].value ) {
                console.log( " ==" );
                return 0;}
            else if (myTable.rows[j].cells[0].childNodes[0].value > myTable.rows[k].cells[0].childNodes[0].value ) { 
                console.log( " > " );
                return -1;}
        }
        console.log("check 20.1");
        console.log(myTable.rows);
        console.log("check 20.2");
        console.log(myTable.rows.length);
        console.log("check 20.2.1");
        //console.log(myTable.rows[0].cells[0].childNodes[0].value);
        //console.log(myTable.rows[1].cells[0].childNodes[0].value);
        console.log("check 20.3");
        var h = 1;
        console.log("check 20.4");
        console.log("( h)" + ( h));
        for (var h = 1; h < myTable.rows.length; h++){
            console.log("check 20.4.1");
            console.log("( h)" + ( h));
            console.log("(myTable.rows.length - h)" + (myTable.rows.length - h));
            for (var i = 0; i < (myTable.rows.length - h) ; i++ )
            {
                console.log("check 20.5");
                if (compareChainRows( i ,i + 1) == 1) {
                    console.log("NOT Swapping rows");
                } // a<b, so do nothing
                else if (compareChainRows( i ,i + 1 ) == 0) {
                    alert("Error! There are two identical chains! Reset the page and start over.");1
                }
                else if (compareChainRows( i ,i + 1 )){ // Swap these two rows
                    console.log("Swapping rows");
                    myTable.rows[i].parentNode.insertBefore(myTable.rows[i + 1] ,myTable.rows[i]);
                    console.log(" rows = " + myTable.rows.length);
                    console.log(" rows = " + myTable.rows.length);
                }
             }
        } 
        console.log("check 20.7");
        for (var h = 0; h < myTable.rows.length; h++) console.log("Row "+ h + " has : " + myTable.rows[h].cells[0].childNodes[0].value );   
    }
    // This just takes all the elements of document.remainingPdbChains and creates options in the drop down list.
    function repopulateOptions(localChainSelector){
        console.log(document.remainingPdbChains);
        document.remainingPdbChains.sort();
        console.log("check 30.6 " + document.remainingPdbChains);
        // depopulate the list of options, in case it is not empty:
        var totalChildren = localChainSelector.childElementCount;
        for (var i= 0; i < totalChildren; i++) {localChainSelector.removeChild(localChainSelector.childNodes[0]);}
        console.log(localChainSelector.childElementCount);
        console.log("check 30.8 localChainSelector.value = " + localChainSelector.value)
        console.log(document.remainingPdbChains);
        for (var i = 0 ; i< document.remainingPdbChains.length ; i++){
            console.log("check 30.8 localChainSelector.value = " + localChainSelector.value)
            var myChainId = document.remainingPdbChains[i]; 
            var myOption = document.createElement("option");
            console.log("check 31.0");
            console.log(myChainId);
            //console.log(myChainId.value); // this member does not exist
            //console.log(myChainId.chainId);
            console.log(document.remainingPdbChains[i]);
            myOption.value = myChainId; 
            myOption.innerHTML = myChainId; 
            localChainSelector.appendChild(myOption);
        }
        console.log("check 30.8 localChainSelector.value = " + localChainSelector.value)
        //populateRemainingPdbChains(); // Just added this, might not be necessary but seems safe.
    }
        function createChainSelector(numComplex){
            var myTable =  document.getElementById("chains"+numComplex+"Table");  
            // Chain ID selector:
            var createdChainSelector = document.createElement("SELECT");
            createdChainSelector.id = "complex" + numComplex + "ChainSelector" + (myTable.rows.length - 1); //tableNumRows is always 1 less than  myTable.rows.length
            createdChainSelector.name = createdChainSelector.id;
            createdChainSelector.onfocus = function(){
                console.log(document.remainingPdbChains);
                this.previous = this.value;
                
                console.log("check 26.4");
                populateRemainingPdbChains(); // Just added this, might not be necessary but seems safe.
                if (document.remainingPdbChains.indexOf(this.previous) == -1){  // This should always happen actually, as we just called populateRemainingPdbChains
                    document.remainingPdbChains.push(this.previous);
                } // have to temporarioy add this.previous to remainingPdbChains in order to repopulate properly
                else {
                    //alert("Problem!");
                }
                repopulateOptions(createdChainSelector);   // This just takes all the elements of document.remainingPdbChains and creates options in the drop down list.
                console.log("check 26.4.2"); 
                populateRemainingPdbChains(); // have to remove the selected element from remainingPdbChains again
                //document.remainingPdbChains.splice(document.remainingPdbChains.indexOf(this.previous),1) ; // have to remove the selected element from remainingPdbChains again
                 
                // Make the prior value the current selected value. 
                for (var i= 0; i <    createdChainSelector.childElementCount; i++) {
                    if (createdChainSelector.childNodes[i].value ==  this.previous){
                        createdChainSelector.selectedIndex = i;
                    }
                }
            }
            createdChainSelector.onchange = function(){
               console.log(document.allPdbChains.length -1);
               console.log("check 1");
               populateRemainingPdbChains(); // This will remove the currently selected value
               //document.remainingPdbChains.splice(document.remainingPdbChains.indexOf(this.value),1) ;
               //if (document.remainingPdbChains.indexOf(this.previous) == -1){ 
               //    document.remainingPdbChains.push(this.previous);} // The prior option is now available for use again
               sortChainRows(1);  
               sortChainRows(2);  
            }
            return createdChainSelector;
        }

    function addChainRow( numComplex ){
        document.getElementById("pdbId").readonly = true;
        console.log(document.allPdbChains.length -1);
        document.getElementById("deleteChain" + numComplex + "Button").disabled = false; 
        var myTable =  document.getElementById("chains"+numComplex+"Table");  
        var tableNumRows = myTable.rows.length;
        myTable.insertRow(tableNumRows); 
        
        myTable.rows[tableNumRows].insertCell(0); 
        var myChainSelector = createChainSelector(numComplex);

        console.log(document.remainingPdbChains);
        console.log("check 30.0");
        repopulateOptions(myChainSelector);
        console.log("check 30.1");
        myTable.rows[tableNumRows].cells[0].appendChild(myChainSelector);
        
        // If we reached the maximum number of rows, disable the add mutation button
        if (document.remainingPdbChains.length == 1)
        { 
            document.getElementById("addChain1Button").disabled = true; 
            document.getElementById("addChain2Button").disabled = true; 
            alert("This is the last chain left to select from. You are not allowed to make further selections without deleting a chain from one of the two complexes.");                                                                               
        }
        else if (myTable.rows.length == (document.allPdbChains.length -1))
        {// probably set to num chains in PDB minus one.
            document.getElementById("addChain" + numComplex + "Button").disabled = true; 
            alert("You are only allowed to specify " +  (document.allPdbChains.length -1) + " chains for this , based on a total number of " + document.allPdbChains.length + " available chains");
        }
        else if ((myTable.rows.length == 4) || (myTable.rows.length == (document.allPdbChains.length -1)))
        {// probably set to num chains in PDB minus one.
            document.getElementById("addChain1Button").disabled = true; 
            alert("You have reached the maximum number of chains: 4");
        }
        document.remainingPdbChains.splice(document.remainingPdbChains.indexOf(myChainSelector.value ),1) ; // have to delete the selected element 
        document.getElementById("addSubstitutionButton").disabled = false;
        if ((document.getElementById("chains1Table").rows.length == 0) || ( document.getElementById("chains2Table").rows.length  == 0)){
            document.getElementById("addSubstitutionButton").disabled = true; 
        }
        sortChainRows(numComplex);  
        //sortChainRows(2);  
        }
    function deleteChainRow(numComplex){
        //// Now have to add the value to be deleted, back to remainingPdbChains :
        var myTable =  document.getElementById("chains" + numComplex + "Table");
        var selectorToDelete = "complex" + numComplex + "ChainSelector" + (myTable.rows.length - 1);
        var valueOfSelectorToDelete = document.getElementById(selectorToDelete).value;
        console.log(valueOfSelectorToDelete);
        console.log(document.remainingPdbChains);
        //document.remainingPdbChains.push(valueOfSelectorToDelete);
        if (document.remainingPdbChains.indexOf(valueOfSelectorToDelete) == -1){ 
            document.remainingPdbChains.push(valueOfSelectorToDelete);} // The prior option is now available for use again
        ////
        console.log(document.remainingPdbChains);
               
        var tableNumRows = myTable.rows.length;
        if (tableNumRows == 0) {
           // do nothing
           alert("Error");
           //document.getElementById("deleteMutationButton").disabled = true; 
        }
        else {
           myTable.deleteRow(myTable.rows.length - 1);
           tableNumRows = myTable.rows.length; 
           if (tableNumRows == 0) {
               document.getElementById("deleteChain" + numComplex + "Button").disabled = true; 
                 
           }
        }
        document.getElementById("addChain" + numComplex + "Button").disabled = false; // If we removed a row, then we are definitely not at the maximum number of rows
        if (document.getElementById("chains1Table").rows.length < (document.allPdbChains.length-1)){
            document.getElementById("addChain1Button").disabled = false;
        }
        if (document.getElementById("chains2Table").rows.length < (document.allPdbChains.length-1)){
            document.getElementById("addChain2Button").disabled = false;
        }
        if ((document.getElementById("chains1Table").rows.length == 0) || ( document.getElementById("chains2Table").rows.length  == 0)){
            document.getElementById("addSubstitutionButton").disabled = true; 
        }
    }


    function deleteSubstitutionRow(){
        var myTable =  document.getElementById("substitutionTable");
        var tableNumRows = myTable.rows.length;
        if (tableNumRows == 0) {
           // do nothing
           alert("Error");
           //document.getElementById("deleteMutationButton").disabled = true; 
        }
        else {
           myTable.deleteRow(myTable.rows.length - 1);
           tableNumRows = myTable.rows.length; 
           if (tableNumRows == 0) {
               document.getElementById("deleteMutationButton").disabled = true; 
               document.getElementById("submit-btn").disabled = true; 
           } 
        }
        document.getElementById("addSubstitutionButton").disabled = false; // If we removed a row, then we are definitely not at the maximum number of rows
    }
    function chainTablesInCorrectOrder(){
        console.log("check 22.0");
        var complex1chain0Id = document.getElementById("chains1Table").rows[0]
        if ((document.getElementById("chains1Table").rows.length == 0) ||  (document.getElementById("chains2Table").rows.length == 0)){
            console.log("At least one of the two chains tables is empty. Not valid to check chain ordering!");
            return 1;
        }
        if (document.getElementById("chains1Table").rows[0].cells[0].childNodes[0].value > document.getElementById("chains2Table").rows[0].cells[0].childNodes[0].value){
            console.log("check 23.0");
            alert("Your first complex starts with chain " + document.getElementById("chains1Table").rows[0].cells[0].childNodes[0].value + " which is alphabetically higher than the first chain of the second complex, " + document.getElementById("chains2Table").rows[0].cells[0].childNodes[0].value + ". This is not allowed! Please put chain " + document.getElementById("chains2Table").rows[0].cells[0].childNodes[0].value + " in the first complex, and chain "  + document.getElementById("chains1Table").rows[0].cells[0].childNodes[0].value + " in the second complex. This is a measure to avoid making redundant calculations."); 
            return 0;
        } else {
            console.log("check 24.0");
            return 1;
        }
        console.log("check 22.1");
        //var complex2chain0Id = document.getElementById("chains1Table").
        /*var myOriginalTable1 = document.getElementById("chains1Table");
        var myOriginalTable2 = document.getElementById("chains2Table");

        //var myNewTable1 = document.getElementById("chains1Table").cloneNode(true);
        //myOriginalTable1.rows[0];
        document.getElementById("chains2Table").insertRow(0); 
        document.getElementById("chains2Table").rows[0] =  document.getElementById("chains1Table").rows[0]; 
        console.log("check 23");
        console.log("check 22");
        var tableNumRows = document.getElementById("chains1Table").rows.length;
        document.getElementById("chains1Table").insertRow(tableNumRows); 
        
        document.getElementById("chains1Table").rows[tableNumRows].insertCell(0); 
        var myChainSelector = createChainSelector(1);
        repopulateOptions(myChainSelector);

        console.log(document.remainingPdbChains);
        document.getElementById("chains1Table").rows[tableNumRows].cells[0].appendChild(myChainSelector);
        console.log("check 23");
        */

    }

    function formSubmitProcedure(){
        //sortChainTables();
        sortSubstitutionRows( );
         
        console.log(document.readyState);
        console.log(document.getElementById("mainForm"));
        console.log(document.forms.length); 
        console.log(document.forms[0]    ); 
        console.log(document.getElementById("mainForm"));
        if(document.readyState === 'complete'){} ;
        document.mainForm.submit();        
    }
    function sortSubstitutionRows( ){
        var mySubstitutionTable = document.getElementById("substitutionTable");  
        function compareSubstitutionRows(j,k){
            console.log(mySubstitutionTable.rows.length );
            if (mySubstitutionTable.rows[j].cells[0].childNodes[0].value < mySubstitutionTable.rows[k].cells[0].childNodes[0].value ) {
                console.log( " < " );
                return 1;}
            else if (mySubstitutionTable.rows[j].cells[0].childNodes[0].value == mySubstitutionTable.rows[k].cells[0].childNodes[0].value ) { // The chains are the same for j,k. So check the residue numbers.
                if (mySubstitutionTable.rows[j].cells[1].childNodes[0].value < mySubstitutionTable.rows[k].cells[1].childNodes[0].value ){
                    console.log( " < " );
                    return 1;
                } 
                else if (mySubstitutionTable.rows[j].cells[1].childNodes[0].value > mySubstitutionTable.rows[k].cells[1].childNodes[0].value ){
                    console.log( " > " );
                    return -1;
                } 
                else {
                    console.log( " ==" );
                    return 0;
                }
            }
            else if (mySubstitutionTable.rows[j].cells[0].childNodes[0].value > mySubstitutionTable.rows[k].cells[0].childNodes[0].value ) { 
                console.log( " > " );
                return -1;}
        }
        console.log(mySubstitutionTable.rows);
        //mySubstitutionTable.rows.sort(sortSubstitutionRows);
        for (var h = 1; h < mySubstitutionTable.rows.length; h++)
            for (var i = 0; i < (mySubstitutionTable.rows.length - h) ; i++ )
            {
                if (compareSubstitutionRows( i ,i + 1) == 1) {
                    console.log("NOT Swapping rows");
                } // a<b, so do nothing
                else if (compareSubstitutionRows( i ,i + 1 ) == 0) {
                    alert("Error! There are two identical substitutions! Reset the page and start over.");1
                }
                else if (compareSubstitutionRows( i ,i + 1 )){ // Swap these two rows
                    console.log("Swapping rows");
                    mySubstitutionTable.rows[i].parentNode.insertBefore(mySubstitutionTable.rows[i + 1] ,mySubstitutionTable.rows[i]);
                    console.log(" rows = " + mySubstitutionTable.rows.length);
                    console.log(" rows = " + mySubstitutionTable.rows.length);
                }
             }
        for (var h = 0; h < mySubstitutionTable.rows.length; h++) {
            console.log("Row "+ h + " has : " + mySubstitutionTable.rows[h].cells[0].childNodes[0].value );  
            // After sorting, we need to set the .id and .name properties of these selectors. 
            mySubstitutionTable.rows[h].cells[0].childNodes[0].id = "chainId" + h;                                      
            mySubstitutionTable.rows[h].cells[0].childNodes[0].name = mySubstitutionTable.rows[h].cells[0].childNodes[0].id;      
            mySubstitutionTable.rows[h].cells[1].childNodes[0].id = "residueNumber" + h;                                      
            mySubstitutionTable.rows[h].cells[1].childNodes[0].name = mySubstitutionTable.rows[h].cells[1].childNodes[0].id;      
            mySubstitutionTable.rows[h].cells[2].childNodes[0].id = "substitutedResidueType" + h;                                      
            mySubstitutionTable.rows[h].cells[2].childNodes[0].name = mySubstitutionTable.rows[h].cells[2].childNodes[0].id;      
        }
    }
    function addSubstitutionRow(){
        document.getElementById("submit-btn").disabled = true; // We enable the Submit button only after the user selects a substitution
        var complex1 = "";
        var complex2 = "";
        for (var i = 0; i < document.getElementById("chains1Table").rows.length; i++) complex1 += document.getElementById("chains1Table").rows[i].cells[0].childNodes[0].value;
        for (var i = 0; i < document.getElementById("chains2Table").rows.length; i++) complex2 += document.getElementById("chains2Table").rows[i].cells[0].childNodes[0].value;
        console.log(" >" + complex1 + "< ");
        console.log(" >" + complex2 + "< ");
        // somehow populatePdbPrimaryArray was getting called here..
        //populatePdbPrimaryArray(complex1, complex2);
        addChain1Button.disabled = true;
        addChain2Button.disabled = true;
        deleteChain1Button.disabled = true;
        deleteChain2Button.disabled = true;
        document.getElementById("deleteMutationButton").disabled = false; 
        var mySubstitutionTableHeader = document.getElementById("substitutionTableHeader");
        if (mySubstitutionTableHeader.rows.length == 0){
            mySubstitutionTableHeader.insertRow(0);
            mySubstitutionTableHeader.rows[0].insertCell(0);
            mySubstitutionTableHeader.rows[0].insertCell(1);
            mySubstitutionTableHeader.rows[0].insertCell(2);
            mySubstitutionTableHeader.rows[0].cells[0].innerHTML = "Chain";
            mySubstitutionTableHeader.rows[0].cells[1].innerHTML = "Residue";
            mySubstitutionTableHeader.rows[0].cells[2].innerHTML = "Substitution";
        }
        var mySubstitutionTable = document.getElementById("substitutionTable");  
        var standardSubstitutionColumnWidth = "100000px";
        mySubstitutionTable.style.columnWidth = standardSubstitutionColumnWidth;
        mySubstitutionTableHeader.style.columnWidth = standardSubstitutionColumnWidth;
        var tableNumRows = mySubstitutionTable.rows.length;
        mySubstitutionTable.insertRow(tableNumRows);  
        mySubstitutionTable.rows[mySubstitutionTable.rows.length - 1].insertCell(0); 
        mySubstitutionTable.rows[mySubstitutionTable.rows.length - 1].insertCell(1); 
        mySubstitutionTable.rows[mySubstitutionTable.rows.length - 1].insertCell(2); 

        // If the table has any prior entries, disable modification of those:
        if (mySubstitutionTable.rows.length > 1){
        }

        // Chain ID selector:
        var myChainSelector = document.createElement("SELECT");

        for (var i = 0 ; i< document.allPdbChains.length ; i++){
            var myChainId = document.allPdbChains[i]; 
            if (document.remainingPdbChains.indexOf(myChainId) == -1) {
                var myOption = document.createElement("option");
                myOption.value = myChainId; 
                myOption.innerHTML = myChainId; 
                myChainSelector.appendChild(myOption);}
        }

        mySubstitutionTable.rows[mySubstitutionTable.rows.length - 1].cells[0].appendChild(myChainSelector);
        myChainSelector.onchange = function(){
            updatePdbResidueIdArrayAndPopulateSelector(); // This should be dependent on the actual chain
        }
        // Residue number selector:
        var myResidueNumberSelector = document.createElement("SELECT");
        myResidueNumberSelector.id = "residueNumber" + (mySubstitutionTable.rows.length - 1);
        console.log(myResidueNumberSelector.id);
        myResidueNumberSelector.name = myResidueNumberSelector.id;        
        mySubstitutionTable.rows[mySubstitutionTable.rows.length - 1].cells[1].appendChild(myResidueNumberSelector); 
        
        var xhttp = new XMLHttpRequest();
        updatePdbResidueIdArrayAndPopulateSelector(); // This should ultimately be dependent on the actual chain chosen. So we populate based on the default chain here, and above in the myChainSelector.onchange event we repopulate upon change of chain choice. 
        var myTempResidueIdArray = []; // casting these as arrays
        var myResidueIdArray = []; // casting these as arrays
        xhttp.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {
                var myTempResidueIdArray = JSON.parse(this.responseText);
                console.log(myTempResidueIdArray.length);
                for (var i = 0; i < (mySubstitutionTable.rows.length - 1); i++){ // Note that this will not count the current row. If there is only one row in substitutionTable, then this loop will not run at all.
                    console.log(i);
                    // If the chain in substitution i matches the chain of the current substitution, then we need to remove a residue Id from the current  myTempResidueIdArray so it cannot be selected again:
                    var valueToDelete = "" ; // cast as string
                    if ( mySubstitutionTable.rows[i].cells[0].childNodes[0].value == mySubstitutionTable.rows[mySubstitutionTable.rows.length - 1].cells[0].childNodes[0].value) {
                        valueToDelete = mySubstitutionTable.rows[i].cells[1].childNodes[0].value;
                        residueIdIndexToDelete = myTempResidueIdArray.indexOf(valueToDelete);                                
                        for (var j = 0; j < myTempResidueIdArray.length; j++){
                            //console.log(" >" + myTempResidueIdArray[j].residueId + "< compared to >" + valueToDelete +"<");
                            if (myTempResidueIdArray[j].residueId == valueToDelete) {residueIdIndexToDelete = j;}
                        }
                        myTempResidueIdArray.splice(residueIdIndexToDelete,1); // Remove the already-used residue ID.
                        console.log(mySubstitutionTable.rows[i].cells[1].childNodes[0].value);
                        console.log(residueIdIndexToDelete);                        
                    }
                } 
                console.log(myTempResidueIdArray.length);
                myResidueIdArray = [];
                for (var i = 0; i< myTempResidueIdArray.length; i++){
                    var myResidueId = ""; // let's cast the elements as strings early on
                    myResidueId = myTempResidueIdArray[i].residueId;
                    myResidueIdArray.push(myResidueId); // This should be an ordinary array, rather than an array of key-values .
                }
           } else {
           }
           populateResidueNumberSelector();
        }; 
        myResidueNumberSelector.onchange = function(){
            //sortSubstitutionRows();
            //updatePdbResidueIdArrayAndPopulateSelector(); // This should be dependent on the actual chain chosen! Right now it seems to populate based on the first chain on the list. --SCF
        }
        function updatePdbResidueIdArrayAndPopulateSelector(){
            console.log("check 1");
            xhttp.open("POST", "calls.php", true ); // Going with asynchronous as I don't want to move on until the chains are ready. Revisit this decision later.
            xhttp.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"); // this turns out to be crucial!
            // Argument is user-provided PDB ID:
            var myChainId = myChainSelector.value;
            console.log(myChainId);
            xhttp.send("restcall=getPdbResidueIds&arguments[0]=" +  document.getElementById("pdbId").value + "&" + "arguments[1]=" + myChainId ) ; // calls.php contains a SWITCH on 'restcall'
        }
        function populateResidueNumberSelector(){
            var totalChildren = myResidueNumberSelector.childElementCount;
            for (var i= 0; i < totalChildren; i++) {
                //console.log(i);
                myResidueNumberSelector.removeChild(myResidueNumberSelector.childNodes[0]);}
            console.log(myResidueIdArray.length);
            for (var i = 0 ; i< myResidueIdArray.length ; i++){
                //console.log(i);
                var myResidueId = myResidueIdArray[i];
                var myOption = document.createElement("option");
                myOption.value = myResidueId;
                myOption.innerHTML = myResidueId;
                myResidueNumberSelector.appendChild(myOption);
            }
        } 

        // Substituted residue type selector
        var mySubstitutedResidueTypeSelector = document.createElement("SELECT");
        // best to set the name and id properties after sorting. Could also set them here, can revisit decision later.
        //mySubstitutedResidueTypeSelector.id = "substitutedResidueType" + (mySubstitutionTable.rows.length - 1);
        //mySubstitutedResidueTypeSelector.name = mySubstitutedResidueTypeSelector.id ;                
       // myResidueNumberSelector.id = "residueNumber" + (mySubstitutionTable.rows.length - 1);
        //myResidueNumberSelector.name = myResidueNumberSelector.id;
        
        function populatemySubstitutedResidueTypeSelector(){
            
            var aminoAcidTypes = ["?","A","R","N","D","C","E","Q","G","H","I","L","K","M","F","P","S","T","W","Y","V"];
            for (var i = 0; i < aminoAcidTypes.length ; i++){
                var mySubstitutedResidueTypeOption = document.createElement("option");
                mySubstitutedResidueTypeOption.value = aminoAcidTypes[i];
                mySubstitutedResidueTypeOption.innerHTML = aminoAcidTypes[i]; 
                mySubstitutedResidueTypeSelector.appendChild(mySubstitutedResidueTypeOption);
            };
        }
        populatemySubstitutedResidueTypeSelector();
        mySubstitutionTable.rows[mySubstitutionTable.rows.length - 1].cells[2].appendChild(mySubstitutedResidueTypeSelector); 
        /*if (mySubstitutionTable.rows.length == 1){
            mySubstitutionTable.rows[mySubstitutionTable.rows.length - 1].cells[0].innerHTML = "Chain<br>";
            mySubstitutionTable.rows[mySubstitutionTable.rows.length - 1].cells[1].innerHTML = "Residue<br>";
            mySubstitutionTable.rows[mySubstitutionTable.rows.length - 1].cells[2].innerHTML = "Substitution<br>";
        }*/
        console.log(myResidueNumberSelector.value);
        mySubstitutedResidueTypeSelector.onfocus = function(){repopulateSubstitutedAminoAcidTypeOptions(mySubstitutedResidueTypeSelector.parentNode.parentNode.rowIndex);}
        mySubstitutedResidueTypeSelector.onchange= function(){
            document.getElementById("submit-btn").disabled = false; // We enable the Submit button only after the user selects a substitution
        }

        // If we reached the maximum number of rows, disable the add mutation button
        if (mySubstitutionTable.rows.length == 4){
            document.getElementById("addSubstitutionButton").disabled = true; 
            alert("You have reached the maximum number of mutations: 4");
        }
        }



function repopulateSubstitutedAminoAcidTypeOptions(rowIndex){
//function repopulateSubstitutedAminoAcidTypeOptions(localSubstitutedResidueTypeSelector, pdbId, chainId, residueId){
    /*
    var mySubstitutionTable = document.getElementById("substitutionTable");
    var pdbId = "1AXI"; //document.getElementById("pdbId").value;
    var localSubstitutedResidueTypeSelector =  mySubstitutionTable.rows[ rowIndex ].cells[2].childNodes[0];
    //var rowIndex = localSubstitutedResidueTypeSelector.parentNode.parentNode.rowIndex;
    //console.log(localSubstitutedResidueTypeSelector, pdbId, chainId, residueId);
    var aminoAcidTypes = ["?","A","R","N","D","C","E","Q","G","H","I","L","K","M","F","P","S","T","W","Y","V"];
            var chainId   = mySubstitutionTable.rows[ rowIndex ].cells[0].childNodes[0].value;
            console.log(chainId);
            var residueId = mySubstitutionTable.rows[ rowIndex ].cells[1].childNodes[0].value;
            console.log(residueId);
    var xhttp = new XMLHttpRequest(); 

    xhttp.onreadystatechange = function() {
        if (this.readyState == 4 && this.status == 200) {
            console.log((this.responseText)) ;
            console.log(JSON.parse(this.responseText)) ;
            var myTempAminoAcidTypeArray = JSON.parse(this.responseText);
            //return (myTempAminoAcidTypeArray[0].aminoAcidType);
          while (localSubstitutedResidueTypeSelector.hasChildNodes()) {
              localSubstitutedResidueTypeSelector.removeChild(node.lastChild);
          }
            for (var i = 0; i < aminoAcidTypes.length ; i++){ 
                if (myTempAminoAcidTypeArray[0].aminoAcidType != aminoAcidTypes[i]) {
                    var mySubstitutedResidueTypeOption = document.createElement("option");
                    mySubstitutedResidueTypeOption.value = aminoAcidTypes[i];
                    mySubstitutedResidueTypeOption.innerHTML = aminoAcidTypes[i]; 
                    localSubstitutedResidueTypeSelector.appendChild(mySubstitutedResidueTypeOption);
                }
            };
        } else {
            console.log(this.status) ;
            console.log(this.readystate) ;
            console.log((this.responseText)) ;
        }
    }
    xhttp.open("POST", "calls.php", true );
    xhttp.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"); // this turns out to be crucial!
    var callString ="restcall=getPdbChains&arguments[0]=" + pdbId ; // + "&arguments[1]=" + chainId + "&arguments[2]=" + residueId;
    //var callString ="restcall=getWildTypeAminoAcidType&arguments[0]=" + pdbId + "&arguments[1]=" + chainId + "&arguments[2]=" + residueId;
    console.log(callString);
    xhttp.send("callString");
    */



            var mySubstitutionTable = document.getElementById("substitutionTable");
            var localSubstitutedResidueTypeSelector =  mySubstitutionTable.rows[ rowIndex ].cells[2].childNodes[0];
            var xhttp = new XMLHttpRequest(); // May need variant to handle old IE browsers https://www.w3schools.com/js/js_ajax_http.asp
            console.log("Detected 1 at your PDB ID is valid. You may now add chains.");

            xhttp.onreadystatechange = function() {
                if (this.readyState == 4 && this.status == 200) {
                    console.log(JSON.parse(this.responseText)) ;
                    var myWildTypeResidueType = JSON.parse(this.responseText);
		    while (localSubstitutedResidueTypeSelector.hasChildNodes()) {
		        localSubstitutedResidueTypeSelector.removeChild(localSubstitutedResidueTypeSelector.childNodes[0]);
		    }
                    var aminoAcidTypes = ["?","A","R","N","D","C","E","Q","G","H","I","L","K","M","F","P","S","T","W","Y","V"];
                    for (var i = 0; i< aminoAcidTypes.length; i++){
                        console.log(myWildTypeResidueType[0].aminoAcidType);  
                        console.log(aminoAcidTypes[i]);  
                        //document.allPdbChains.push(myWildTypeResidueType[i].chainId); // trying to make sure the array gets passed by value not reference
                        //document.remainingPdbChains.push(myWildTypeResidueType[i].chainId); // trying to make sure the array gets passed by value not reference
                        if (aminoAcidTypes[i] != myWildTypeResidueType[0].aminoAcidType){
                            var mySubstitutedResidueTypeOption = document.createElement("option");
                            mySubstitutedResidueTypeOption.value = aminoAcidTypes[i];  
                            mySubstitutedResidueTypeOption.innerHTML = aminoAcidTypes[i];                       
                            localSubstitutedResidueTypeSelector.appendChild(mySubstitutedResidueTypeOption);
                        }
                    }
                } else {
                    console.log(this.status) ;
                }
            }; 
            xhttp.open("POST", "calls.php", true ); // Going with asynchronous as I don't want to move on until the chains are ready. Revisit this decision later.
            console.log(this.status) ;
            xhttp.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"); // this turns out to be crucial!
            console.log(document.getElementById("pdbId").value );
            var pdbId = document.getElementById("pdbId").value;
            var chainId   = mySubstitutionTable.rows[ rowIndex ].cells[0].childNodes[0].value;
            var residueId = mySubstitutionTable.rows[ rowIndex ].cells[1].childNodes[0].value;
            // Argument is user-provided PDB ID:
            var callString ="restcall=getWildTypeAminoAcidType&arguments[0]=" + pdbId + "&arguments[1]=" + chainId + "&arguments[2]=" + residueId;
            //var callString ="restcall=getPdbChains&arguments[]=" + document.getElementById("pdbId").value;                                        
	    console.log(callString);
	    xhttp.send(callString); 
            //xhttp.send("restcall=getWildTypeAminoAcidType&arguments[]=" + document.getElementById("pdbId").value ); // calls.php contains a SWITCH on 'restcall'
            //xhttp.send("restcall=getPdbChains&arguments[]=" + document.getElementById("pdbId").value ); // calls.php contains a SWITCH on 'restcall'
}

$(document).ready(function() {
	if (user != "Guest") {
		loadAccInfo();
                console.log("check 33 "       );                    
	}else {
                console.log("check 34 "       );                    
		document.getElementById("submit-div").innerHTML = "The job submitting process is only allowed to registered users. Please register or Log-in first.";
	}
});
</script>
	<style>
		html {
		}
		
		html,body {
			height:100%;
			width: 100%;
			margin: 0;
			padding: 0;
		}
		
		#submit-mid {
			font-size: 75%;
			margin: 0;
			height: 100%;
			background: url("images/WAL-5.jpg") no-repeat center center fixed;
			background-size: cover;
			text-align:center;
		}
		
		#submit-div {
			border-radius: 10px 10px 10px 10px;
			border-style: solid;
			border-width: 1px;
			overflow: visible;
			width: 400px;
			margin: auto;
			padding: 10px 20px;
			opacity: 0.85;
			position: relative;
			top: 20%;
			overflow: auto;
		}
		
		#submitInfo-div {

		}
		
		#submitForm-div {

		}

		table tr th input {
			width: 100% !important;
		}
		
		#submit-btn {
			width: 100px;
			height: 30px;
			font-size: 14px;
		}
	</style>

</html>



